<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Week 3 - Multi-Agent Systems, Memory, Learning &#8212; CC-MAS 2016 0.1a documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="CC-MAS 2016 0.1a documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="week-3-multi-agent-systems-memory-learning">
<h1>Week 3 - Multi-Agent Systems, Memory, Learning<a class="headerlink" href="#week-3-multi-agent-systems-memory-learning" title="Permalink to this headline">Â¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There is now an example implementation (which is hopefully bug free) of
an agent using Nth order MC in the repository. The code is not fully
documented, so find out the interesting parts yourself.</p>
<p class="last"><a class="reference external" href="https://github.com/assamite/cc-mas-course/blob/master/week3/markov_agent.py">(agent code)</a></p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Familiarize yourself with the example of an agent with a limited memory
of artifacts it has most recently seen (see <a class="reference internal" href="mas_memory.html"><span class="doc">Agents With Memory and Learning From Domain</span></a>). The next
exercises are heavily based on it.</p>
</li>
<li><p class="first"><strong>RETURN</strong> In the example (see previous exercise), the memory model is a
photographic (eidetic) one, holding the recently seen artifact instances as is.
However, as you might remember from the Ventura&#8217;s paper from the first week, it
does not necessarily have to be so simple. Instead, it could change the
representation of the artifacts as Ventura mentions in <em>memorization</em>, or
even generalize the artifacts to more abstract representations as is the
case with <em>generalization</em>.</p>
<p>Give some examples of real implementable models that could be used as the
memory of an agent (you can think of any models you have previously encountered,
e.g. from machine learning or data mining). You can choose the domain of
the artifacts and its restrictions as you see fit as long as you state
them clearly in your answer. What pros and cons does your memory model have?
Write your answer briefly (10-15 sentences).</p>
<p>Additional notes:</p>
<blockquote>
<div><ul class="simple">
<li>The important functionality of the memory model is that it should be
able to help in assessing the new artifact&#8217;s novelty based on the
previously seen artifacts.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>RETURN</strong> Use the memory model given in the example in your own code:</p>
<blockquote>
<div><ul class="simple">
<li>Adjust your agent class (the one with MC as the generative model) to use the
<code class="xref py py-class docutils literal"><span class="pre">ListMemory</span></code> in the same way as in the example i.e. use it to
compute the novelty of an artifact and refactor <code class="xref py py-func docutils literal"><span class="pre">evaluate()</span></code> to
take into account both the novelty and the value. Value function can
be the same function you implemented the last week, or the
(pseudo)likelihood.</li>
<li>Adjust your <code class="xref py py-meth docutils literal"><span class="pre">ToyEnvironment.vote()</span></code> to add the winner&#8217;s of the vote
to the domain as described in the example.</li>
<li>Add the memorization of both the agent&#8217;s own artifacts and random
domain artifacts to <code class="xref py py-func docutils literal"><span class="pre">act()</span></code>.</li>
</ul>
<p>Additional things to look at if interested:</p>
<ul class="simple">
<li>Experiment with different memory capacities (between different societies
or between different agents in the same society). Do you see any differences?</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>RETURN</strong> Towards transformational creativity</p>
<p>Background:</p>
<p>In this exercise, we will implement a simple functionality
which makes the agents adjust their generative model during their lifespan.
This functionality could be stated to be the first step towards the
transformational creativity (if we are pompous). The functionality is
implemented by changing (or adding to) the inner Markov chain representation
of the agent.</p>
<p>Until now, the agents have only used constant state transition
probability data structures, which have been given or learned at the
initialization time, to generate new pieces of text. Now, we will change
the transition probabilities based on observed instances of text. To
implement this, we will go a step backwards and keep count of the actual number of each
state transition (i.e. <code class="docutils literal"><span class="pre">state_transitions</span></code> in the first week&#8217;s example)
in each agent. That is, each agent should either learn the state transition
counts (<strong>not</strong> probabilities) from the given file at initialization time,
or they are given this data structure.</p>
<p>Furthermore, each agent should have an access to
simple function which then transforms these state transitions counts into
probabilities. However, the state transition counts should be modifiable
at all times (and new transition probabilities computable).</p>
<p>We will update the state transition counts when the agent observes the
domain artifacts in <code class="xref py py-func docutils literal"><span class="pre">act()</span></code>. In the example, agent has a random access
to the previous vote winning artifacts (domain) which they currently
only memorize into their memory model. To modify our generative model, we add to the
agent&#8217;s state transitions counts each state transition that is observed
from the domain artifact. Then, we update the state transition probabilities
based on the current state transition counts.</p>
<p>Specification:</p>
<p>Implement a method <code class="xref py py-meth docutils literal"><span class="pre">learn(self,</span> <span class="pre">artifact)()</span></code> in your agent
class. The method takes as input <code class="xref py py-class docutils literal"><span class="pre">Artifact</span></code> object, and updates the
state transition counts with each state transition that is observed from
the artifact (remember that the actual string was in <code class="docutils literal"><span class="pre">obj</span></code> attribute
of the artifact object). Use appropriate tokenization method (depending
on your MC implementation) to split the string first and then observe the
state transitions from the tokenized string. The function (or some helper
function) then adds these state transitions to your state transition counts.
If new states and state transitions are observed, add them to the data
structure as well. Then, compute the new state transition probabilities
for the agent. Call this in <code class="xref py py-func docutils literal"><span class="pre">act()</span></code> for the domain artifact that was
memorized (if there was any domain artifacts), before the agent invents
new artifact.</p>
</li>
<li><p class="first"><strong>RETURN</strong> After you have built the functionality from the previous exercise,
run the simulation for an agent population with at least two different
sources of MC models. Observe if the transformational properties of the
agents affect the agents liking of the inner groups (agents with the same starting
MC model) or outer groups (agents with the different starting MC model) in the
long run. You may have to run the simulation quite a long time (some thousands of
iterations). What do you observe? State your findings briefly. You may
use plots, images or other visualization methods (in fact you are encouraged
to).</p>
<p>Additional notes:</p>
<blockquote>
<div><ul class="simple">
<li>Splitting the long run into even length intervals and computing some
aggregate measures from the voting behavior during each interval can
be a good starting point. However, you may do the observations any way
you like as long as you are able to extract some interesting bits of
information of what happens in the society during the system run (if
anything happens at all).</li>
<li>Try to be as elaborate as you can get in your observations. Why things
happen or do not happen?</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>RETURN</strong> Design and implement an agent interaction model, where agents ask directly
others opinions about their artifacts and may take the information they
see viable into account by modifying their generative model or
evaluation function (or both). The interaction model does not have to be complex,
and the rules when the agents learn something from the feedback can be
simple. We have free rein of your own design! Write a short description of your model.
Return both the description and the code.</p>
<dl class="docutils">
<dt>Additional notes:</dt>
<dd><ul class="first last simple">
<li>There is now <a class="reference external" href="https://github.com/assamite/cc-mas-course/blob/master/week3/communication.py">a short example</a>
of interaction between agents in the repository.</li>
</ul>
</dd>
</dl>
<p>Examples:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Ask opinion about the artifact they invented from a random agent. If agent likes (or dislikes) the
artifact, update state transition counts (and probabilities) with the
states of the artifact. Experiment with different thresholds for &#8216;liking&#8217;.</li>
<li>Same as above but also update agent so that it is more likely to ask
opinion from agents that have given it positive feedback. Negative
feedback may or may not change the agents preferences.</li>
<li>Implement another agent class, <code class="xref py py-class docutils literal"><span class="pre">LibrarianAgent</span></code>, that does not
invent artifacts, but only memorizes artifacts from the domain. If the
artifact memorized from the domain is very good (the agent should have
notions of value and novelty), it spreads it to few random agents in
the society. Put few of these agents into a society and remove other
agents&#8217; access to the domain. What happens? Why?</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">CC-MAS 2016</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preliminaries.html">1. Preliminaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="course_format.html">2. Course Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="linguistic_creativity.html">3. Linguistic Creativity</a></li>
<li class="toctree-l1"><a class="reference internal" href="mas.html">4. Multi-Agent Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="assignments.html">5. Assignments</a></li>
<li class="toctree-l1"><a class="reference internal" href="zz_references.html">6. References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Simo Linkola.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.8</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/ex_mas_memory.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>